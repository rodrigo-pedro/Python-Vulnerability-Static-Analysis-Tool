import copy
import json
import sys


class VarTaint:
    def __init__(self, name, isRogue = False):
        self.name = name
        self.sanitized = False
        self.sanitizedBy = []
        self.isRogue = isRogue


    def sanitize(self, sanitizer):
        if sanitizer not in self.sanitizedBy:
            self.sanitized = True
            self.sanitizedBy.insert(0, sanitizer)

    def __eq__(self, other): 
        if not isinstance(other, VarTaint):
            return NotImplemented

        return self.name == other.name and self.sanitized == other.sanitized \
        and self.sanitizedBy == other.sanitizedBy and self.isRogue == other.isRogue


class Vulnerability:
    def __init__(self, name, source, sink, isSanitized, sanitizer):
        self.name = name
        self.source = source
        self.sink = sink
        self.isSanitized = isSanitized
        self.sanitizer = sanitizer

    def __str__(self):
        if self.isSanitized:
            return "VULNERABILITY: {0} {1} --> {2}  with sanitizer/s: {3}" \
            .format(self.name, self.source, self.sink, self.sanitizer)
        else:
            return "VULNERABILITY: {0} {1} --> {2} without sanitizer" \
            .format(self.name, self.source, self.sink)
        
    def __eq__(self, other): 
        if not isinstance(other, Vulnerability):
            return NotImplemented
            
        return self.name == other.name and self.source == other.source \
        and self.sink == other.sink and self.isSanitized == other.isSanitized \
        and self.sanitizer == other.sanitizer

    def get_dictionary(self):
        return {
            "vulnerability": self.name,
            "source": self.source,
            "sink": self.sink,
            "unsanitized flows": "no" if self.isSanitized else "yes",
            "sanitized flows": [] if len(self.sanitizer) == 0 else [self.sanitizer]
        }
        


#----------------------------------------------------------------------------------------



# Inicio
"""
    O module pode receber mais do que um contexto de uma vez mas 
    por cada linha de codigo, são enviados (todos os contextos) um de cada vez

"""
def module(data, contexts):
    returned_contexts = []
    for i in data["body"]:
        for context in contexts:
            returned_contexts += select_path(i, context)
        contexts = copy.deepcopy(returned_contexts)
        returned_contexts = []
    return contexts


# Literals(Constant)
def constant(data, context):
    return []


# Variables(Name)
"""
    A função name indica se o nó é tainted
    (1) Se o nó está no contexto e tem entradas no array
    (2) Se o nó é uma source (a = source)
    (3) Se o nó é rogue (uma variabel que nunca foi declarada/existiu neste contexto)
"""

def name(data, context):

    out_lbls = []
    if data["id"] in context: #dois primeiros casos
        if len(context[data["id"]]) != 0 :   # (1)
            out_lbls += copy.deepcopy(context[data["id"]])

        if data["id"] in vul["sources"]: # (2)
            out_lbls.append(VarTaint(data["id"], False))

        return out_lbls
    else: #sou rogue, retorno so a label (3)
        return [VarTaint(data["id"], True)]




# Statements (Assign)
"""
    A função assign deve atualizar UM contexto de cada vez:
    (1) a = 2, meter no contexto {a : []} para simbolizar que a variavel foi 
        declarada mas que não está tainted
    (2) a =  var_tainted, meter no contexto {a: [VarTaint(var_tainted)]}
    
    Para printar as vulnerabilidades:
        (3) Se o que está à esquerda for um sink e à direita for um VarTaint (quer seja sanitized ou não)

"""

def assign(data, context):

    new_context = copy.deepcopy(context)

    path_lbls = select_path(data["value"], context)

    if len(implicit_stack):
        path_lbls += implicit_stack[-1]

    for target in data["targets"]:
        if target["id"] in vul["sinks"]:
            for lbl in path_lbls:
                if lbl.name in vul["sources"] or lbl.isRogue:
                    if lbl.sanitized:
                        found_vulns.append(Vulnerability(vul["vulnerability"], lbl.name, target["id"], True, lbl.sanitizedBy))
                    else:
                        found_vulns.append(Vulnerability(vul["vulnerability"], lbl.name, target["id"], False, []))

        # fim do (3)        
        new_context.update({ target["id"]: path_lbls})  # (1) (2)

    return [new_context]




"""
    A função call deve colocar labels indicando se estão tainted ou não
    (1) func(a, var_tainted) - Se um dos argumentos for tainted, é acrescentado às labels uma instância de VarTaint
    (2) func(var_tainted, var_tainted) - Por cada var_tainted é adicionada uma instância de varTaint às labels, e cada uma diz se está sanitizada ou não
    (3) sanitizador(var_tainted, a) - atualizar o varTaint para que este passe a estar sanitizado por esta chamada
    (4) Se esta chamada for uma source, o varTaint é adicionado às labels.
    
    Para printar as vulnerabilidades:
        (5) Se a chamada for um sink e os args forem varTaint vamos printar a vulnerabilidade tendo em conta se é
            sanitized ou não
"""


def call(data, context):
    
    out_lbls = []
    func = data["func"]["id"]

    if func in vul["sources"]: #(4)
        out_lbls.append(VarTaint(func, False))

    for arg in data["args"]:
        arg_lbls = select_path(arg, context)

        for lbl in arg_lbls:
            if lbl.name in vul["sources"] or lbl.isRogue:  # isto só interessa se lbl estiver na vulnerabilidade
                if func in vul["sanitizers"]: #a chamada é um sanitizador (3)
                    lbl.sanitize(func)
                elif func in vul["sinks"]: #(5)
                    if lbl.sanitized:
                        found_vulns.append(Vulnerability(vul["vulnerability"], lbl.name, func, True, lbl.sanitizedBy))

                    else:
                        found_vulns.append(Vulnerability(vul["vulnerability"], lbl.name, func, False, []))


        out_lbls += copy.deepcopy(arg_lbls) #(1) (2) e (3) também

    return out_lbls

  

# Expressions(Expr, BinOp, Compare, Call, Atribute)
def expr(data, context):
    select_path(data["value"], context)
    return [context]



"""
    A função binary_operation retorna a junção das labels da esquerda e da direita
"""
def binary_operation(data, context):

    left = select_path(data["left"], context)
    right= select_path(data["right"], context)

    out_lbls = []
    aux = left + right
    [out_lbls.append(i) for i in aux if i not in out_lbls] #evitar labels repetidas

    return out_lbls


"""
    A função compare retorna a junção das labels da esquerda e da direita
"""

def compare(data, context):
    out_lbls = []
    left = select_path(data["left"], context)
    for i in data["comparators"]:
        out_lbls += select_path(i, context)

    final = []
    aux = out_lbls + left
    [final.append(i) for i in aux if i not in final] #evitar labels repetidas
    return final



# Control flow -> if and while
"""
    A função if_node envia uma cópia do contexto atual para o if e uma para o else
    Os select_path retornam contextos e tudo junto é retornado
"""
def if_node(data, context):

    if vul["implicit"] == "yes":
        test_lbls = select_path(data["test"], context)
        if len(implicit_stack):
            implicit_stack.append(test_lbls + implicit_stack[-1])
        else:
            implicit_stack.append(test_lbls)

    
    body_contexts = [copy.deepcopy(context)]
    for i in data["body"]:
        aux = []
        for ctx in body_contexts:
            aux += select_path(i, ctx)

        body_contexts = copy.deepcopy(aux)


    orelse_contexts = [copy.deepcopy(context)]
    for i in data["orelse"]:
        aux = []
        for ctx in orelse_contexts:
            aux += select_path(i, ctx)

        orelse_contexts = copy.deepcopy(aux)
    

    if vul["implicit"] == "yes":
        implicit_stack.pop()

    return body_contexts + orelse_contexts


def while_node(data, context):

    # a stack armazena as labels do contexto em que se esta (util para nested whiles e if)
    # assim as variaveis que estao dentro do novo contexto, estao tainted pela condicao
    if vul["implicit"] == "yes":
        test_lbls = select_path(data["test"], context)
        if len(implicit_stack):
            implicit_stack.append(test_lbls + implicit_stack[-1])
        else:
            implicit_stack.append(test_lbls)


    # por cada loop é overwritten
    body_contexts = [copy.deepcopy(context)]

    out_body_contexts = []

    for i in range(0, 5):
        for j in data["body"]:
            aux = []
            for ctx in body_contexts:
                aux += select_path(j, ctx)

            body_contexts = copy.deepcopy(aux)
            out_body_contexts += body_contexts

        # no fim de cada loop, se é implicito volto a testar
        if vul["implicit"] == "yes":
            new_contexts = []
            for k in out_body_contexts:
                new_contexts += select_path(data["test"], k)
            implicit_stack[-1] = new_contexts + implicit_stack[-1]



    not_while_contexts = [copy.deepcopy(context)] # no caso em que nao se entra no while
    
    after_while = out_body_contexts + not_while_contexts 

    if len(data["orelse"]):
        temp_ctxs = copy.deepcopy(after_while)
        else_ctxs = []
        for i in data["orelse"]:
            for ctx in temp_ctxs:
                else_ctxs += select_path(i, ctx)
        after_while += else_ctxs 

    if vul["implicit"] == "yes":
        implicit_stack.pop()
   


    return after_while




def break_node(data, context):
    return [context]


def attribute(data, ctx):   
    return select_path(data["value"], ctx)
    

def select_path(data, ctx):
    switch = {
        "Module": module,
        "Constant": constant,
        "Name": name,
        "Expr": expr,
        "BinOp": binary_operation,
        "Compare": compare,
        "Call": call,
        "Attribute": attribute,
        "Assign": assign,
        "If": if_node,
        "While": while_node,
        "Break": break_node,
    }

    return switch[data["ast_type"]](data, ctx)



programFile = open(sys.argv[1], "r")
vulnFile = open(sys.argv[2], "r")
outputFile = open(sys.argv[1].split(".json")[0] + ".output.json", "w")

vulns = json.load(vulnFile)
program = json.load(programFile)

outputDict = []

#----------------------------------------------

# construir o json
for vul in vulns:
    found_vulns = []
    implicit_stack = []
    final_ctxs = select_path(program, [{}])
   

    new_found_vulns = []
    [new_found_vulns.append(i) for i in found_vulns if i not in new_found_vulns]

    for found_vul in new_found_vulns:
        print(found_vul)

        new_dict = found_vul.get_dictionary()

        for dict in outputDict:
            if dict["vulnerability"] == new_dict["vulnerability"] and dict["source"] == new_dict["source"] and dict["sink"] == new_dict["sink"]:
                if len(new_dict["sanitized flows"]):
                    dict["sanitized flows"] +=new_dict["sanitized flows"]
                    
                if new_dict["unsanitized flows"] == "yes":
                    dict["unsanitized flows"] = "yes"

                break
        else:
            outputDict.append(new_dict)

json.dump(outputDict, outputFile)
#----------------------------------------------

programFile.close()
vulnFile.close()
outputFile.close()
